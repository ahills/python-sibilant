;; This library is free software; you can redistribute it and/or modify
;; it under the terms of the GNU Lesser General Public License as
;; published by the Free Software Foundation; either version 3 of the
;; License, or (at your option) any later version.
;;
;; This library is distributed in the hope that it will be useful, but
;; WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
;; Lesser General Public License for more details.
;;
;; You should have received a copy of the GNU Lesser General Public
;; License along with this library; if not, see
;; <http://www.gnu.org/licenses/>.

;; author: Christopher O'Brien  <obriencj@gmail.com>
;; license: LGPL v.3


;; === defines ===

(define-global defmacro
  (macro
   "defmacro"
   (function defmacro (name formals . &body)
	     (doc "Defines a Macro instance in the current module")
	     `(define-global ,name
		(macro ,(str name) (function ,name ,formals ,@&body))))))


(defmacro defun (name params . &body)
  `(define ,name (function ,name ,params ,@&body)))


(defmacro defclass (name bases . &body)
  `(define ,name (class ,name ,bases ,@&body)))


(defun help-macroexpand-1 (the-macro argbody)
  (cond ((macro? the-macro)
	 (apply the-macro.expand argbody))
	(else
	 (raise (Exception (% "not a macro %r" the-macro))))))


(defmacro macroexpand-1 (expr)
  `(help-macroexpand-1 ,(car expr) (quote ,(cdr expr))))


(defmacro set-macro-character args
  `(__reader__.set_macro_character ,@args))


;; === conditionals ===

(defmacro if (condition true_body . &false_body)
  `(cond (,condition ,true_body)
	 (else ,(cond (&false_body (car &false_body))
		      (else None)))))


(defmacro when (condition . &body)
  `(cond (,condition ,@&body)
	 (else None)))


(defmacro unless (condition . &body)
  `(cond (,condition None)
	 (else ,@&body)))


;; === math shortcuts ===

(defmacro incr (dest . by)
  (cond
   ((nil? by)
    (set-var by 1))

   ((nil? (cdr by))
    (set-var by (car by)))

   (else
    (raise (Exception "too many argument to incr"))))

  `(setf ,dest (+ ,dest ,by)))


(defmacro decr (dest . by)
  (cond
   ((nil? by)
    (set-var by 1))

   ((nil? (cdr by))
    (set-var by (car by)))

   (else
    (raise (Exception "too many argument to decr"))))

  `(setf ,dest (- ,dest ,by)))


;; === imports ===

(defmacro defimport (modulename . &as_name)
  (doc "Import a module and bind it to the global scope")

  (unless (symbol? modulename)
    (raise (Exception (% "defimport module name must be a symbol, not %r"
			 modulename))))

  (unless (or (nil? &as_name) (== 1 (&as_name.count)))
    (raise (Exception ("unexpected additional arguments to defimport"))))

  (setq &as_name
	(if (nil? &as_name) (item (modulename.split "." 1) 0)
	  (car &as_name)))

  `(define ,&as_name (import ,(str modulename) (globals))))


(defmacro defimportfrom (modulename . &bindings)
  (doc "Import definitions from a module and bind them to the"
       "global scope")

  (unless (symbol? modulename)
    (raise (Exception (% "defimportfrom module name must be a symbol, not %r"
			 modulename))))

  (let ((coll (list))
	(current None)
	(member None)
	(byname None))

    (while &bindings
      (setq current (car &bindings))

      (setq member (if (pair? current) (first current) current))
      (setq byname (if (pair? current) (second current) member))

      (coll.append
       `(define ,byname (get-attr (import ,(str modulename) (globals) None
					  (make-list ,(str member)))
			      ,member)))

      (setq &bindings (cdr &bindings)))

    `(begin ,@coll)))


;; === setf and general variables ===

(let ((*gv-forms* (make-dict)))

  (defun gv-define-setter-fn (name fn)
    (set-item *gv-forms* name fn)
    None)

  (defmacro gv-define-setter (name formals . &body)
    `(gv-define-setter-fn
      ',name
      (lambda ,formals ,@&body)))

  (defmacro gv-define-simple-setter (name setter)
    `(gv-define-setter
      ,name (dest val) `(,',setter ,@dest ,val)))

  (defmacro setf (target value)
    (cond
     ((symbol? target)
      (if (in (str target) ".")
	  (let ((spltrgt (target.rsplit "." 1)))
	    `(set-attr ,(item spltrgt 0) ,(item spltrgt 1) ,value))
	`(setq ,target ,value)))

     ((and (proper? target) (in *gv-forms* (car target)))
      ((item *gv-forms* (car target)) (cdr target) value))

     (else
      (raise (Exception (% "invalid setf target %s" target)))))))

(begin
  (gv-define-simple-setter attr set-attr)
  (gv-define-simple-setter car set-car)
  (gv-define-simple-setter cdr set-cdr)
  (gv-define-simple-setter item set-item)
  (gv-define-simple-setter global define-global)
  (gv-define-setter caar (val x) `(set-car (car ,x) ,val))

  None)


;; === local variable definitions ===

(defmacro local (name . &dfn)
  (let ((target (first &dfn)))
    (cond ((or (eq target 'function) (eq target 'class))
	   `(define-local ,(second &dfn) ,&dfn))
	  (else
	   (raise (Exception (% "invalid local definition %" target)))))))


;; === python object system classes ==

(defmacro method (name params . &body)
  `(let ((*method* (lambda ,params ,@&body))
	 (*name* ,(str name)))
     (set-attr *method* __name__ *name*)
     (set-item *members* *name* *method*)))


(defmacro class (name bases . &body)
  `(let ((*name* ,(str name))
	 (*flds* None)
	 (*body* (lambda (*members*)
		   (begin ,@&body)
		   *members*)))

     (setq *flds* (*body* (dict)))
     (set-item *flds* "__doc__" *body*.__doc__)
     (type *name*
	   (make-tuple ,@bases)
	   *flds*)))


;;
;; The end.
