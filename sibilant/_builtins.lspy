;; This library is free software; you can redistribute it and/or modify
;; it under the terms of the GNU Lesser General Public License as
;; published by the Free Software Foundation; either version 3 of the
;; License, or (at your option) any later version.
;;
;; This library is distributed in the hope that it will be useful, but
;; WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
;; Lesser General Public License for more details.
;;
;; You should have received a copy of the GNU Lesser General Public
;; License along with this library; if not, see
;; <http://www.gnu.org/licenses/>.

;; author: Christopher O'Brien  <obriencj@gmail.com>
;; license: LGPL v.3



(defmacro if (condition true_body . &false_body)
  `(cond (,condition ,true_body)
	 (else ,(cond (&false_body (car &false_body))
		      (else 'False)))))


(defmacro when (condition . &body)
  `(cond (,condition (begin ,&body))
	 (else 'False)))


(defmacro unless (condition . &body)
  `(cond (,condition 'False)
	 (else (begin ,&body))))


(defmacro incr (dest . by)
  (cond
   ((nil? by)
    (set-var by 1))

   ((nil? (cdr by))
    (set-var by (car by)))

   (else
    (raise (Exception "too many argument to incr"))))

  `(set! ,dest (+ ,dest ,by)))


(defmacro decr (dest . by)
  (cond
   ((nil? by)
    (set-var by 1))

   ((nil? (cdr by))
    (set-var by (car by)))

   (else
    (raise (Exception "too many argument to decr"))))

  `(set! ,dest (- ,dest ,by)))


(defmacro def-import (name . &as_name)
  (set-var &as_name
	(if (nil? &as_name) name (car &as_name)))

  `(define ,&as_name (import ,(str name))))


;;(defmacro def-import-from (modulename name . &as_name)
;;  (set-var &as_name
;;	(if (nil? &as_name) name (car &as_name)))
;;
;;  `(define ,&as_name (import-from ,(str modulename) ,(str name))))


(defmacro set! (target value)
  (cond
   ((symbol? target)
    (if (in (str target) ".")
	(let ((spltrgt (target.rsplit "." 1)))
	  `(setf ,(item spltrgt 0) ,(item spltrgt 1) ,value))
	`(set-var ,target ,value)))

   ((and (proper? target))
    (let ((trigger (car target)) (dest (cdr target)))
      `(begin
	,(cond ((eq 'car trigger) `(set-car ,@dest ,value))
	       ((eq 'cdr trigger) `(set-cdr ,@dest ,value))
	       ((eq 'item trigger) `(set-item ,@dest ,value)))
	None)))

   (else
    (raise (Exception (% "invalid set! target %s" target))))))


(defun help-macroexpand-1 (the-macro argbody)
  (if (macro? the-macro)
      (apply the-macro.expand argbody)
    (raise (Exception (% "not a macro")))))


(defmacro macroexpand-1 (expr)
  `(help-macroexpand-1 ,(car expr) (quote ,@(cdr expr))))


;;
;; The end.
