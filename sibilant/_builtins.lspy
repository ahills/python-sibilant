;; This library is free software; you can redistribute it and/or modify
;; it under the terms of the GNU Lesser General Public License as
;; published by the Free Software Foundation; either version 3 of the
;; License, or (at your option) any later version.
;;
;; This library is distributed in the hope that it will be useful, but
;; WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
;; Lesser General Public License for more details.
;;
;; You should have received a copy of the GNU Lesser General Public
;; License along with this library; if not, see
;; <http://www.gnu.org/licenses/>.

;; author: Christopher O'Brien  <obriencj@gmail.com>
;; license: LGPL v.3


;; === defines ===

(define-global defmacro
  (macro
   "defmacro"
   (function defmacro (name formals . body)
	     (doc "Defines a Macro instance in the current module")

	     (define proper (proper? formals))
	     `(define-global ,name
		((lambda (M) (set-attr M _proper ,proper) M)
		 (macro ,(str name) (function ,name ,formals ,@body)))))))


(defmacro defmacrolet (name . body)
  (doc "Defined a Macrolet in the current module")
  `(define-global ,name
     (macrolet ,(str name) (function ,name () ,@body))))


(defmacro defun (name params . body)
  `(define-global ,name (function ,name ,params ,@body)))


(defmacro defclass (name bases . body)
  `(define-global ,name (class ,name ,bases ,@body)))


;; === reader macros and atom matchers ===


(defmacrolet set-event-macro `__reader__.set_event_macro)

(defmacrolet get-event-macro `__reader__.get_event_macro)

(defmacrolet clear-event-macro `__reader__.clear_event_macro)

(defmacrolet temp-event-macro `__reader__.temporary_event_macro)

(defmacrolet set-macro-character `__reader__.set_macro_character)

(defmacrolet temp-macro-character `__reader__.temporary_macro_character)

(defmacrolet set-atom-pattern `__reader__.set_atom_pattern)

(defmacrolet get-atom-pattern `__reader__.get_atom_pattern)

(defmacrolet clear-atom-pattern `__reader__.clear_atom_pattern)

(defmacrolet set-atom-regex `__reader__.set_atom_regex)


;; === conditionals ===

(defmacro if (condition then: True else: False)
  `(cond (,condition ,then)
	 (else: ,else)))


(defmacro when (condition . body)
  `(cond (,condition ,@body)
	 (else: None)))


(defmacro unless (condition . body)
  `(cond (,condition None)
	 (else: ,@body)))


;; === math shortcuts ===

(defmacro incr (dest by: 1)
  `(setf ,dest (+ ,dest ,by)))


(defmacro decr (dest by: 1)
  `(setf ,dest (- ,dest ,by)))


;; === simple checks ===

(defmacro none? (value)
  `(is None ,value))


;; === imports ===

(defmacro defimport (modulename as-name: None)
  (doc "Import a module and bind it to the current scope")

  (unless (symbol? modulename)
    (raise (Exception (% "defimport module name must be a symbol, not %r"
			 modulename))))

  (unless (or (none? as-name) (symbol? as-name))
    (raise (Exception "defimpoy as-name: must be a symbol")))

  (when (none? as-name)
    (setq as-name (item (modulename.split "." 1) 0)))

  `(define ,as-name (import ,(str modulename) (globals))))


(defmacro defimportfrom (modulename . &bindings)
  (doc "Import definitions from a module and bind them to the"
       "current scope")

  (unless (symbol? modulename)
    (raise (Exception (% "defimportfrom module name must be a symbol, not %r"
			 modulename))))

  (let ((coll (list))
	(current None)
	(member None)
	(byname None))

    (while &bindings
      (setq current (car &bindings))

      ;; todo: use my cooler binding exploder
      (setq byname (if (pair? current) (first current) member))
      (setq member (if (pair? current) (second current) current))

      (coll.append
       `(define ,byname
	  (attr (import ,(str modulename) (globals) None
			(build-list ,(str member)))
		,member)))

      (setq &bindings (cdr &bindings)))

    `(begin ,@coll)))


;; === runtime macroexpand ===

(defimportfrom sibilant.compiler
  (macroexpandq-1 macroexpand_1)
  (macroexpandq macroexpand))


(defmacro macroexpand-1 (source)
  `(macroexpandq_1 (globals) ',source))

(defmacro macroexpand (source)
  `(macroexpandq (globals) ',source))


;; === setf and general variables ===

(let ((*gv-forms* (dict)))

  (defun gv-define-setter-fn (name fn)
    (set-item *gv-forms* name fn)
    None)

  (defmacro gv-define-setter (name formals . body)
    `(gv-define-setter-fn
      ',name
      (lambda ,formals ,@body)))

  (defmacro gv-define-simple-setter (name setter)
    `(gv-define-setter
      ,name (dest val) `(,',setter ,@dest ,val)))

  (defmacro setf (target value)
    (cond
     ((symbol? target)
      (if (in (str target) ".")
	  (let ((spltrgt (target.rsplit "." 1)))
	    `(set-attr ,(item spltrgt 0) ,(item spltrgt 1) ,value))
	`(setq ,target ,value)))

     ((and (proper? target) (in *gv-forms* (car target)))
      ((item *gv-forms* (car target)) (cdr target) value))

     (else:
      (raise (Exception (% "invalid setf target %s" target))))))

  None)


(begin
  (gv-define-simple-setter attr set-attr)
  (gv-define-simple-setter car set-car)
  (gv-define-simple-setter cdr set-cdr)
  (gv-define-simple-setter item set-item)
  (gv-define-simple-setter global define-global)
  (gv-define-setter caar (val x) `(set-car (car ,x) ,val))

  None)


;; === def general targets ===


(let ((*gd-targets* (dict))
      (*gd-scopes* (dict)))

  (defun gd-define-scope-fn (key fn)
    (set-item *gd-scopes* key fn)
    None)

  (defmacro gd-define-scope (name formals . body)
    `(gd-define-scope-fn
      (keyword ,name)
      (lambda ,formals ,@body)))

  (defmacro gd-define-simple-scope (name setter)
    `(gd-define-scope
      ,name (dest val) `(,,setter ,dest ,val)))

  (defun gd-define-target-fn (name fn)
    (set-item *gd-targets* name fn)
    None)

  (defmacro gd-define-target (name formals . body)
    `(gd-define-target-fn
      (symbol ',name)
      (lambda ,formals ,@body)))

  (defmacro gd-define-simple-target (name factory)
    `(gd-define-target ,name (setter source)
		       (setter (car source) `(,,factory ,@(cdr source)))))


  (defmacro def source
    (let ((scope ':local)
	  (target None)
	  (d-scope None)
	  (d-target None))

      (when (keyword? (car source))
	(setq scope (car source))
	(setq source (cdr source)))

      (print *gd-scopes*)
      (setq d-scope (dict.get *gd-scopes* scope None))
      (when (none? d-scope)
	(raise (Exception (% "undefined def scope %r" scope))))

      (setq target (car source))
      (setq source (cdr source))

      (setq d-target (dict.get *gd-targets* target None))
      (when (none? d-target)
	(raise (Exception (% "undefined def target %r" target))))

      (print "scope:" scope)
      (print "target:" target)
      (print "source:" source)

      (d-target d-scope source)))

  None)

(begin
 (gd-define-simple-scope ':local 'define)
 (gd-define-simple-scope ':global 'define-global)
 ;; todo: thread-local

 None)

(begin
 (gd-define-simple-target function 'function)
 (gd-define-simple-target classy 'class)

 None)


;; === c_r magic ===

;; (defmacro c__r (atom)
;;   (unless (is str (type atom))
;;     (raise (Exception (% "what happened in c__r: %r" atom))))

;;   (define sb (attr (import "sibilant.builtins") builtins))
;;   (define sd sb.__dict__)

;;   (define found (dict.get sd atom None))

;;   (when (none? found)
;;     (define calls (reduce (lambda (cell atom-char)
;; 				  (cons (if (eq "a" atom-char) 'car 'cdr)
;; 					cell))
;; 				(item atom (slice -2 1 -1))
;; 				nil))

;;     (setq found
;; 	  (macro atom
;; 		 (lambda (value)
;; 		   `(,(if (eq "a" (item atom 1)) 'car 'cdr)
;; 		     (reduce (lambda (x y) (y x)) (values ,@calls)
;; 			     ,value)))))

;;     (print (found.expand 'TACO))

;;     (setf (item sd atom) found)
;;     None)

;;   (symbol atom))


;; (set-atom-regex 'c__r "c[ad]{2,}r" (lambda (atom) `(c__r ,atom)))

;; (defmacrolet first 'car)
;; (defmacrolet second 'cadr)
;; (defmacrolet third 'caddr)
;; (defmacrolet fourth 'cadddr)
;; (defmacrolet fifth 'caddddr)
;; (defmacrolet sixth 'cadddddr)
;; (defmacrolet seventh 'caddddddr)


;; === local variable definitions ===

(defmacro local (name . dfn)
  (let ((target (first dfn)))
    (cond ((or (eq target 'function) (eq target 'class))
	   `(define ,(second dfn) ,dfn))
	  (else:
	   (raise (Exception (% "invalid local definition %" target)))))))


;; === python object system classes ==

(defmacro method (name params . body)
  `(let ((method (function ,name ,params ,@body))
	 (name ,(str name)))
     (set-item *members* name method)
     None))


(defmacro class (name bases . body)
  `(let ((body (lambda (*members*)
		 (begin ,@body)
		 *members*))
	 (flds (dict :__module__ __name__)))

     (body flds)
     (set-item flds "__doc__" body.__doc__)
     (type ,(str name) (values ,@bases) flds)))


(defmacro compile (source env: None filename: "<anon>")
  (when (none? env) (setq env '(globals)))

  `(let ((src ,source) (io (import "io")) (sib (import "sibilant.compiler")))
     (if (isinstance src (values str io.IOBase))
	 then: (next (sib.compiler.iter_compile src ,env ,filename))
	 else: (sib.compiler.compile_expression src ,env ,filename))))


(defmacro eval (source env: None)
  (when (none? env) (setq env '(globals)))

  `(let ((src ,source) (types (import "types")))
     (if (isinstance src types.CodeType)
	 then: (py-eval src ,env)
	 else: (py-eval (compile src ,env) ,env))))


;;
;; The end.
