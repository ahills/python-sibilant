;; This library is free software; you can redistribute it and/or modify
;; it under the terms of the GNU Lesser General Public License as
;; published by the Free Software Foundation; either version 3 of the
;; License, or (at your option) any later version.
;;
;; This library is distributed in the hope that it will be useful, but
;; WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
;; Lesser General Public License for more details.
;;
;; You should have received a copy of the GNU Lesser General Public
;; License along with this library; if not, see
;; <http://www.gnu.org/licenses/>.

;; Basic functionality of sibilant. This module is combined with the
;; bootstrap module to provide __builtins__ for other modules written
;; in sibilant.

;; author: Christopher O'Brien  <obriencj@gmail.com>
;; license: LGPL v.3


;; disable TCO for the following stuff, they don't need to bounce
(try
 (set-attr __compiler__ tco_enabled False)
 ([NameError] None))


;; === defines ===

(define-global defmacro
  (macro "defmacro"
   (function defmacro [name formals . body]
     "Defines a Macro instance in the current module"

     (define proper (proper? formals))
     `(define-global ,name
	((lambda [M] (set-attr M _proper ,proper) M)
	 (macro ,(str name) (function ,name ,formals ,@body)))))))


(defmacro defalias [name . body]
  "Defines an Alias Macro in the current module"
  `(define-global ,name
     (alias ,(str name) (function ,name [] ,@body))))


(defmacro defun [name params . body]
  "Defines a function with the given name in the current module"
  `(define-global ,name (function ,name ,params ,@body)))


(defmacro defclass [name bases . body]
  "Defines a class with the given name in the current module"
  `(define-global ,name (class ,name ,bases ,@body)))


(defmacro var [*: variables]
  "
  (var BINDINGS...)

  where each BINDING is either a symbol or a pair in (SYM EXPR)
  format. Declares each binding symbol in the current scope, and
  optionally assigns it the value from EXPR
  "

  ;; (setq variables (to-tuple variables))
  `{,@(map (lambda [d]
	     (cond ((symbol? d) `(define ,d))
		   (else: `(define ,@d))))
	   variables)})


;; === reader macros and atom matchers ===

(defmacro _reader_macro [sym attrsym]
  `(defmacro ,sym args
     `(try
       (unless (None? __reader__)
	 ((attr __reader__ ,',attrsym) ,@args))
       ([NameError as: ne] None))))

(_reader_macro read read)
(_reader_macro set-event-macro set_event_macro)
(_reader_macro get-event-macro get_event_macro)
(_reader_macro clear-event-macro clear_event_macro)
(_reader_macro temp-event-macro temp_event_macro)
(_reader_macro set-macro-character set_macro_character)
(_reader_macro temp-macro-character temp_macro_character)
(_reader_macro set-atom-pattern set_atom_pattern)
(_reader_macro get-atom-pattern get_atom_pattern)
(_reader_macro clear-atom-pattern clear_atom_pattern)
(_reader_macro set-atom-regex set_atom_regex)


;; === conditionals ===

(defmacro if [condition then: True else: False]
  `(cond (,condition ,then)
	 (else: ,else)))


(defmacro when [condition . body]
  `(cond (,condition ,@body)
	 (else: None)))


(defmacro unless [condition . body]
  `(cond (,condition None)
	 (else: ,@body)))


;; === math shortcuts ===

(defmacro incr [dest by: 1]
  `(setf ,dest (+ ,dest ,by)))


(defmacro decr [dest by: 1]
  `(setf ,dest (- ,dest ,by)))


;; === simple checks ===


(defmacro None? [value]
  `(is None ,value))


(defmacro within? [min_i max_i value_i]
  "
  (within? MIN MAX VALUE)

  True if MIN <= VALUE < MAX
  "
  ;; TODO: use a gensym and store value_i to prevent it from
  ;; evaluating twice
  `(and (<= ,min_i ,value_i) (< ,value_i ,max_i)))


(defmacro when-main body
  `(when (== __name__ "__main__") ,@body))


;; === easy slicing ===

(defmacro item-slice [sequence start: 'None stop: 'None step: 1]
  "
  (item-slice SEQUENCE)
  (item-slice SEQUENCE START)
  (item-slice SEQUENCE START STOP)
  (item-slice SEQUENCE START STOP STEP)
  (item-slice SEQUENCE start: START stop: STOP step: STEP)

  slices a sequence, with optional start, stop, and step parameters
  "
  `(item ,sequence (slice ,start ,stop ,step)))


;; === compose raise and exception initializing

(defmacro raise! [exc_type . exc_args]
  `(raise (,exc_type ,@exc_args)))


;; === setf and general variables ===

(let [[*gv-forms* (#dict)]]

  (defun gv-define-setter-fn [name fn]
    (set-item *gv-forms* name fn)
    None)

  (defmacro gv-define-setter [name formals . body]
    `(gv-define-setter-fn
      ',name
      (lambda ,formals ,@body)))

  (defmacro gv-define-simple-setter [name setter]
    `(gv-define-setter
      ,name (dest val) `(,',setter ,@dest ,val)))

  (defmacro setf [target value]

    ;; since sibilant is designed to expand macros lazily, we need to
    ;; jump ahead a bit and make sure that our target gets expanded
    ;; right now so that we can find the right dispatch method.
    (setq target (macroexpandq None target))

    (cond
     [(symbol? target)
      (if (in (str target) ".")
	  then: { (define spltrgt (target.rsplit "." 1))
		  `(set-attr ,(item spltrgt 0) ,(item spltrgt 1) ,value) }
	  else:	`(setq ,target ,value))]

     [(and (proper? target) (in *gv-forms* (car target)))
      ((item *gv-forms* (car target)) (cdr target) value)]

     [else:
      (raise! Exception (% "invalid setf target %s" target))]))

  None)


(gv-define-simple-setter attr set-attr)
(gv-define-simple-setter car set-car)
(gv-define-simple-setter cdr set-cdr)
(gv-define-simple-setter item set-item)
(gv-define-simple-setter global define-global)
(gv-define-setter caar [val x] `(set-car (car ,x) ,val))


;; === def general targets ===

(let [[*gd-targets* (#dict)]
      [*gd-scopes* (#dict)]]

  (defun gd-define-scope-fn [key fn]
    (set-item *gd-scopes* key fn)
    None)

  (defmacro gd-define-scope [name formals . body]
    `(gd-define-scope-fn
      (keyword ,name)
      (lambda ,formals ,@body)))

  (defmacro gd-define-simple-scope [name setter]
    `(gd-define-scope
      ,name [dest val] `(,,setter ,dest ,val)))

  (defun gd-define-target-fn [name fn]
    (set-item *gd-targets* name fn)
    None)

  (defmacro gd-define-target [name formals . body]
    `(gd-define-target-fn
      (symbol ',name)
      (lambda ,formals ,@body)))

  (defmacro gd-define-simple-target [name factory]
    `(gd-define-target ,name [setter source]
		       (setter (item source 0)
			       `(,,factory ,@source))))

  (defmacro def source
    (let [[scope ':local]
	  [target None]
	  [d-scope None]
	  [d-target None]]

      (if (keyword? (item source 0))
	  then: (setq-values [scope target . source] source)
	  else: (setq-values [target . source] source))

      (setq d-scope (dict.get *gd-scopes* scope None))
      (when (None? d-scope)
	(raise! Exception (% "undefined def scope %r" scope)))

      (setq d-target (dict.get *gd-targets* target None))
      (when (None? d-target)
	(raise! Exception (% "undefined def target %r" target)))

      (d-target d-scope source)))

  None)


(gd-define-simple-scope ':local 'define)
(gd-define-simple-scope ':global 'define-global)
 ;; todo: thread-local


(gd-define-simple-target function 'function)
(gd-define-simple-target method 'method)
(gd-define-simple-target class 'class)
(gd-define-simple-target macro 'macro)


;; === def import and def import-from ==

(defun __import-binding [thing]
  (cond
   ((symbol? thing)
    (return (#tuple None thing)))

   ((pair? thing)

    (try  ; (FOO as: BAR)
     (define-values [src [as [bind rest]]] thing)
     ([ValueError] None)
     (else:
      (when (and (nil? rest) (is ':as as))
	    (return (#tuple bind src)))))

    (try  ; (BAR FOO)
     (define-values [bind [src rest]] thing)
     ([ValueError] None)
     (else:
      (when (nil? rest)
	    (return (#tuple bind src)))))
    ))

  (raise! SyntaxError (% "bad binding form: %s" thing)))


(gd-define-target
 import [scopefn source]

 (def function sd [src]
      (define-values [binding module] (__import-binding src))
      (cond
       ((None? binding)
	(setq binding (item (module.split ".") 0))
	(scopefn binding `(import ,module)))

       (else:
	(define ats `(import ,module))
	(when (in (str module) ".")
	  (setq ats (reduce (lambda [t h] `(attr ,t ,h))
			    (item-slice (module.split ".") start: 1)
			    ats)))
	(scopefn binding ats))))

 `{,@(map sd source)})


(gd-define-target
 import-from [scopefn source]

 (define module (item source 0))
 (define source (item-slice source start: 1))

 (def function sd [src]
      (define-values [binding modsrc] (__import-binding src))
      (when (None? binding) (setq binding modsrc))
      (scopefn binding `(item (import-from ,module ,modsrc) 0)))

 `{,@(map sd source)})


;; === runtime macroexpand ===


(def import-from sibilant.compiler
     [macroexpand_1 as: macroexpandq-1]
     [macroexpand as: macroexpandq]
     [simple_parameters as: simple-parameters])

;; the macros just snag globals and quote the source, then pass them
;; on to the quoted expanders imported above
(defmacro macroexpand-1 [source]
  `(macroexpandq_1 (globals) ',source))

(defmacro macroexpand [source]
  `(macroexpandq (globals) ',source))


;; === flet and values ===

(defmacro labels [declarations . body]
  (setq declarations (tuple (declarations.unpack)))
  `(let [,@(map (lambda [d] `(,(car d) None)) declarations)]
     ,@(map (lambda [d] `(def function ,@d)) declarations)
     ,@body))


(defmacro flet [declarations . body]
  (setq declarations (tuple (declarations.unpack)))
  `(let [,@(map (lambda [d] `(,(car d) (lambda ,@(cdr d)))) declarations)]
     ,@body))


(defmacro let-values [bind_vals . body]
  "
  (let-values (BINDINGS VALS) . BODY)

  where BINDINGS is a nested pair of symbols in the same structure as
  values from VALS.
  "

  `(let []
     (define-values ,@bind_vals)
     ,@body))


;; === c_r magic ===

;; (defmacro c__r (atom)
;;   (unless (is str (type atom))
;;     (raise (Exception (% "what happened in c__r: %r" atom))))

;;   (define sb (attr (import "sibilant.builtins") builtins))
;;   (define sd sb.__dict__)

;;   (define found (dict.get sd atom None))

;;   (when (None? found)
;;     (define calls (reduce (lambda (cell atom-char)
;; 				  (cons (if (eq "a" atom-char) 'car 'cdr)
;; 					cell))
;; 				(item atom (slice -2 1 -1))
;; 				nil))

;;     (setq found
;; 	  (macro atom
;; 		 (lambda (value)
;; 		   `(,(if (eq "a" (item atom 1)) 'car 'cdr)
;; 		     (reduce (lambda (x y) (y x)) (values ,@calls)
;; 			     ,value)))))

;;     (print (found.expand 'TACO))

;;     (setf (item sd atom) found)
;;     None)

;;   (symbol atom))


;; (set-atom-regex 'c__r "c[ad]{2,}r" (lambda (atom) `(c__r ,atom)))

;; (defalias first 'car)
;; (defalias second 'cadr)
;; (defalias third 'caddr)
;; (defalias fourth 'cadddr)
;; (defalias fifth 'caddddr)
;; (defalias sixth 'cadddddr)
;; (defalias seventh 'caddddddr)


;; === python object system classes ==

(defmacro class [name bases . body]
  "
  (class NAME (parents... ) . BODY)

  Create a new python type instance with the given name, and parent
  class inheritance. The expressions of BODY are evaluated in order in
  their own local scope. The resulting locals are used to define the
  class members (functions, fields, etc.)

  Use (def class NAME (parents... ) . BODY) to bothe create and bind
  the class in the local namespace.
  "

  `(flet [[create-class [name fields *: bases metaclass: type]
			(metaclass name bases fields)]
	  [create-members [__module__]
			  {,@body} (locals)]]

     (create-class ,(str name)
		   (create-members __name__)
		   ,@bases)))


(defmacro compile [source env: '(globals) filename: "<anon>"]
  "
  (compile SOURCE)

  Returns a python code object

  SOURCE may be one of the following:
   * IOBase stream from which to read and compile a single expression
   * str from which to parse and compile a single expression
   * cons pair representing source forms
   * symbol or keyword object

  (compile SOURCE env: DICT filename: \"filename.lspy\")

  Compiles SOURCE with DICT as the globals, with the source filename
  set to filename.lspy
  "

  `(let [[src ,source] [glbls ,env] [fname ,filename]]
     (def import-from io IOBase)
     (def import-from sibilant.parse
       source_stream source_str)
     (def import-from sibilant.module
       fake_module_from_env init_module parse_time compile_time)

     (define stream
       (cond [(isinstance src str) (source_str src fname)]
	     [(isinstance src IOBase) (source_stream src fname)]
	     [(or (pair? src) (symbol? src) (keyword? src))
	      None]
	     [else: src]))

     (define mod (fake_module_from_env glbls))
     (init_module mod stream filename: fname)

     (unless (or (pair? src) (symbol? src) (keyword? src))
       (setq src (parse_time mod)))

     (compile_time mod src)))


(defmacro eval [source env: '(globals) filename: "<anon>"]
  "
  (eval SOURCE)

  Evaluates SOURCE with the current globals.

  SOURCE may be one of the following:
   * Python code object
   * IOBase stream from which to read and compile a single expression
   * str from which to parse and compile a single expression
   * cons pair representing source forms
   * symbol or keyword object

  (eval SOURCE env: DICT filename: \"filename.lspy\")

  Evaluates SOURCE with DICT as the globals, with the source filename
  set to filename.lspy
  "

  `(let [[src ,source] [glbls ,env] [fname ,filename]]
     (def import-from io IOBase)
     (def import-from types CodeType)
     (def import-from sibilant.parse
       source_stream source_str)
     (def import-from sibilant.module
       fake_module_from_env init_module parse_time compile_time run_time)

     (cond
      [(isinstance src CodeType) (py-eval src glbls fname)]

      [else:
       (define stream
	 (cond [(isinstance src str) (source_str src fname)]
	       [(isinstance src IOBase) (source_stream src fname)]
	       [(or (pair? src) (symbol? src) (keyword? src))
		None]
	       [else: src]))

       (define mod  (fake_module_from_env glbls))
       (init_module mod stream filename: ,filename)

       (unless (or (pair? src) (symbol? src) (keyword? src))
	 (setq src (parse_time mod)))

       (run_time mod (compile_time mod src))])))


(let []
  (def import-from dis dis [show_code as: show-code])

  (defun disassemble [obj details: False]
    "
    (disassemble OBJ)
    (disassemble OBJ details: True)

    display bytecode and optional constant and variable details
    "

    (when details
          (show-code obj)
          (print "Disassembly:"))
    (dis obj)))


(defmacro disassemble-expr [expr]
  "
  (disassemble-expr EXPR)

  compiles EXPR, then decompiles it and displays the bytecode
  operations it would have executed
  "
  `(disassemble (compile ',expr)))


;; === generator stuff ===

(defmacro send [iterator value]
  `((attr ,iterator send) ,value))


(defmacro iter-each [bindings emit *: () when: None unless: None]
  "
  (iter-each (BINDINGS SEQUENCE) EXPRESSION)
  (iter-each (BINDINGS SEQUENCE) EXPRESSION when: WHENTEST)
  (iter-each (BINDINGS SEQUENCE) EXPRESSION unless: UNLESSTEST)

  Produces an iterator which will yield the result of EXPRESSION,
  which is evaluated with the BINDINGS unpacked from each value from
  iterating over SEQUENCE. The optional when and unless forms may be
  specified as predicate expressions to be evaluated on each iteration
  to determine if the given values should be skipped.
  "

  (setq emit `(yield ,emit))
  (when unless (setq emit `(unless ,unless ,emit)))
  (when when (setq emit `(when ,when ,emit)))
  `(let [] (for-each ,bindings ,emit)))


(defmacro list-each params
  "Like iter-each, but accumulates the result into a Python list"
  `(list (iter-each ,@params)))


;; === some simple converters ===


(let [[pair_? pair?]
      [len_ len]
      [tuple_ tuple]
      [list_ list]
      [set_ set]]

  (defun as-tuple [value]
    "
    (to-tuple VALUE)

    Converts VALUE to a tuple. If VALUE is a cons pair, will unpack
    it. Otherwise, VALUE will be iterated over and its contents
    collected.
    "

    (tuple_
     (if (pair_? value)
	 then: (value.unpack)
	 else: value)))


  (defun as-list [value]
    "
    (to-list VALUE)

    Converts VALUE to a list. If VALUE is a cons pair, will unpack
    it. Otherwise, VALUE will be iterated over and its contents
    collected.
    "

    (list_
     (if (pair_? value)
	 then: (value.unpack)
	 else: value)))


  (defun as-set [value]
    "
    (to-set VALUE)

    Converts VALUE to a set. If VALUE is a cons pair, will unpack
    it. Otherwise, VALUE will be iterated over and its contents
    collected.
    "

    (set_
     (if (pair_? value)
	 then: (value.unpack)
	 else: value)))


  (defun length [value]
    "
    (length VALUE)

    The number of items in VALUE. If VALUE is a cons pair, will unpack
    it. Otherwise, identical to (len VALUE)
    "
    (if (pair_? value)
	then: (value.length)
	else: (len_ value)))


  (defun apply [fun arglist: (#tuple) kwargs: (#dict)]
    "
    (apply FUN)
    (apply FUN arglist: POSITIONALS)
    (apply FUN kwargs: KEYWORDS)
    (apply FUN arglist: POSITIONALS kwargs: KEYWORDS)

    Invokes FUN as a function, with optional iterable POSITIONALS as
    positional arguments, and optional mapping KEYWORDS as keyword
    arguments.

    If POSITIONALS is a a cons pair, it will be unpacked instead of
    iterated.
    "

    (when (pair_? arglist) (setq arglist (arglist.unpack)))
    (fun *: arglist **: kwargs))


  None)


;; === Have some MATH ===

;; nobody will ever use these, but I think it's amusing to have them
;; bound like this, ready to go.

(def import-from math
     inf [inf as: ∞] [isinf as: ∞?] [isinf as: inf?]
     [nan as: NaN] [isnan as: NaN?])

(var [-∞ (- ∞)]
     [-inf -∞])


;;
;; The end.
