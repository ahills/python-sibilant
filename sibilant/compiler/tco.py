# This library is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as
# published by the Free Software Foundation; either version 3 of the
# License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, see
# <http://www.gnu.org/licenses/>.


__all__ = (
    "trampoline", "tailcall", "tco_disable",
)


def setup():
    # because this is going to be invoked so frequently, it becomes
    # important that the individual trampoline and tailcall functions
    # are as fast as I can make them in Python. This means no global
    # lookups. Here, all of the functions being applied are available
    # from freevars

    from sys import _xoptions
    from functools import partial, update_wrapper

    _getattr = getattr


    if _xoptions.get("sibilant.ctco", "True") == "True":
        try:
            from .ctco import trampoline, tailcall
        except ImportError:
            pass
        else:
            return trampoline, tailcall


    class TailCall(partial):
        # invocation of partial has very low overhead, so we'll just
        # subclass it. Since this class is fairly well hidden, we can
        # use its type as a sentinel value to detect whether each
        # bounce of the trampoline should be rebounced or returned.
        pass


    def tco_trampoline(work, *args, **kwds):
        work = work(*args, **kwds)
        while work.__class__ is TailCall:
            work = work()
        return work


    def trampoline(fun):
        """
        decorator to wrap a function in a tail call trampoline. Whenever
        the underlying function returns a TailCall instance (as
        generated by wrapping tail position function applications in a
        tailcall wrapper), the trampoline will evaluate it. Once a
        non-TailCall result is acquired, or once an exception is
        raised, the trampoline will exit.
        """

        # note we don't check for _tco_disable here, because by the
        # time we get this far, the function has been compiled
        # expecting to have a trampoline under it, and it will return
        # TailCall objects. Without the trampoline, those would end up
        # in the normal return flow, and would break a bunch of
        # things.

        # if fun is already a wrapped tailcall, or it's a wrapped
        # trampoline, we'll unwrap it first.
        fun = _getattr(fun, "_tco_original", fun)

        fun_trampoline = partial(fun, tco_trampoline)
        update_wrapper(fun_trampoline, fun)

        fun_trampoline._tco_original = fun
        fun_trampoline._tco_enable = True

        return fun_trampoline


    def tailcall(fun):
        if not _getattr(fun, "_tco_enable", False):
            return fun

        # if fun is already a wrapped tailcall, or it's a wrapped
        # trampoline, we'll unwrap it first.
        fun = _getattr(fun, "_tco_original", fun)

        tco_bounce = partial(TailCall, fun)
        tco_bounce._tco_original = fun

        return tco_bounce


    trampoline.__qualname__ = "sibilant.compiler.tco.trampoline"
    tailcall.__qualname__ = "sibilant.compiler.tco.tailcall"
    return trampoline, tailcall


trampoline, tailcall = setup()
del setup


def tco_disable(fun):
    """
    Decorator to instruct the tailcall optimization to never tailcall
    bounce the given function.
    """

    fun._tco_enable = False

    return fun


#
# The end.
