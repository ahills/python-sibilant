# This library is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as
# published by the Free Software Foundation; either version 3 of the
# License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, see
# <http://www.gnu.org/licenses/>.


__all__ = (
    "trampoline", "tailcall", "tco_disable",
)


def setup():
    # because this is going to be invoked so frequently, it becomes
    # important that the individual trampoline and tailcall functions
    # are as fast as I can make them in Python. This means no global
    # lookups. Here, all of the functions being applied are available
    # from freevars

    from functools import partial, wraps
    _ty = type
    _ga = getattr


    class TailCall(partial):
        # invocation of partial has very very low overhead, so we'll
        # just subclass it and inject a single slot for marking up the
        # original function.
        pass


    def trampoline(fun):
        """
        decorator to wrap a function in a tail call trampoline. Whenever
        the underlying function returns a TailCall instance (as
        generated by wrapping tail position function applications in a
        tailcall wrapper), the trampoline will evaluate it. Once a
        non-TailCall result is acquired, or once an exception is
        raised, the trampoline will return that result.
        """

        # note we don't check for _tco_disable here, because by the
        # time we get this far, the function has been compiled
        # expecting to have a trampoline under it, and it will return
        # TailCall objects. Without the trampoline, those would end up
        # in the normal return flow, and would break a bunch of
        # things.

        # if fun is already a wrapped tailcall, or it's a wrapped
        # trampoline, we'll unwrap it first.
        fun = _ga(fun, "_tco_original", fun)

        @wraps(fun)
        def tco_trampoline(*args, **kwds):
            work = fun(*args, **kwds)
            while _ty(work) is TailCall:
                work = work()
            return work

        tco_trampoline._tco_original = fun
        return tco_trampoline


    def tailcall(fun):
        if _ga(fun, "_tco_disable", False):
            return fun

        # if fun is already a wrapped tailcall, or it's a wrapped
        # trampoline, we'll unwrap it first.
        fun = _ga(fun, "_tco_original", fun)

        tco_bounce = partial(TailCall, fun)
        tco_bounce._tco_original = fun

        return tco_bounce


    def tco_disable(fun):
        """
        Decorator to instruct the tailcall optimization to never tailcall
        bounce the given function
        """

        fun._tco_disable = True

        return fun


    return trampoline, tailcall, tco_disable


trampoline, tailcall, tco_disable = setup()
del setup


#
# The end.
