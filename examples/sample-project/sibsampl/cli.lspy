;; This library is free software; you can redistribute it and/or modify
;; it under the terms of the GNU Lesser General Public License as
;; published by the Free Software Foundation; either version 3 of the
;; License, or (at your option) any later version.
;;
;; This library is distributed in the hope that it will be useful, but
;; WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
;; Lesser General Public License for more details.
;;
;; You should have received a copy of the GNU Lesser General Public
;; License along with this library; if not, see
;; <http://www.gnu.org/licenses/>.


(defimport sys)
(defimport timeit)

(defimportfrom argparse
  ArgumentParser
  _AppendAction _AppendConstAction _StoreAction _StoreConstAction)

(defimportfrom os.path basename)

(defimportfrom functools lru_cache)


;; naive memoized fibonacci implementation. I really need to add a way
;; to do pythonic decorators with my (def function ...) syntax
(define fibonacci_
  ((lru_cache (** 2 10))
   (lambda (index)
     (if (< index 2) then: index
	 else: (+ (fibonacci_ (- index 1)) (fibonacci_ (- index 2)))))))

;; since the purpose here is in timing things, we need to make sure to
;; clear the lru_cache between invocations.
(def function fibonacci (index)
     (var result (fibonacci_ index))
     (fibonacci_.cache_clear)
     result)


;; the tail-call recursive impl
(def function fibonacci_tcr (index carry: 0 accu: 1)
  (if (== index 0) then: carry
      else: (fibonacci_tcr (- index 1) accu (+ accu carry))))


;; tail-call optimized BUT NOT RECURSIVE (had to make two functions to
;; make that happen). This will not run out of stack space thanks to
;; the trampoline, but it's also going to be slow because of all those
;; bounces.
(def function fibonacci_tco (index carry: 0 accu: 1)
  (if (== index 0) then: carry
      else: (fibonacci_tco_2 (- index 1) accu (+ accu carry))))
(def function fibonacci_tco_2 (index carry: 0 accu: 1)
  (if (== index 0) then: carry
      else: (fibonacci_tco (- index 1) accu (+ accu carry))))


;; looping version
(def function fibonacci_loop (index)
  (vars (carry 0) (accu 1))

  (while (< 0 index)
    (setq-values
     (index carry accu)
     (values (- index 1) accu (+ accu carry))))

  carry)


(def function funtime (title fun number)
  (try
   (begin
    (var s (timeit.timeit stmt: fun number: number))
    (print (str.format "{title} over {num} loops -> {secs:6.4f}"
		       title: title num: number secs: s)))
   ((BaseException as: be)
    (print (str.format "{title} -> {problem}"
		       title: title problem: be)))))


(def function cli-command-timeit (options)
  (vars (f options.fib) (n options.number))

  (vars
   (d0 (try (fibonacci f) ((BaseException) None)))
   (d1 (fibonacci_loop f))
   (d2 (fibonacci_tco f))
   (d3 (fibonacci_tcr f)))

  ;; kinda wish I had assert...
  ;; TODO implement 'assert'
  (unless (and (== d1 d2) (== d1 d3) (or (none? d0) (== d0 d1)))
    (raise (Exception "SHIT BROKE")))

  (print (% "calculating fibonacci of %r" f))
  (print (% "answer is %r" d1))

  (funtime "fibonacci memoized" (partial fibonacci f) n)
  (funtime "fibonacci via loop" (partial fibonacci_loop f) n)
  (funtime "fibonacci with TCO" (partial fibonacci_tco f) n)
  (funtime "fibonacci with TCR" (partial fibonacci_tcr f) n)

  None)


(def function cli-subp-timeit (parent)
  (var subp (subparser
	     parent "timeit"
	     cli-func: cli-command-timeit))

  (subp.add_argument "--number" action: "store" type: int
		     default: timeit.default_number)

  (subp.add_argument "--fib" action: "store" type: int
		     default: 5000)

  subp)


(def function create-option-parser (argv)
  (doc "the sibapp CLI argument parser")

  (var parser (ArgumentParser
	       prog: (basename (item argv 0))
	       description: "This is sibapp"))

  (parser.add_argument "something" nargs: "*" action: "store"
		       type: str help: "something or another")

  (cli-subp-timeit parser)
  parser)


(define _inherit_actions
  (values _AppendAction _AppendConstAction
	  _StoreAction _StoreConstAction))


(def function subparser (parser name cli-func: None help: None)
  ;; argparse has some crap behaviour that I regularly find myself
  ;; needing to override with this function. I should really move this
  ;; into a sibilant.site.argparse module...

  (var subs
    (if parser._subparsers
	then: (item parser._subparsers._actions -1)
	else: (parser.add_subparsers)))

  (var sp
    (subs.add_parser (str name) help: help description: help))

  (for-each (act parser._subparsers._actions)
	    (when (isinstance act _inherit_actions)
	      (sp._add_action act)))

  (sp._defaults.update parser._defaults)

  (when (none? cli-func)
    (setq cli-func (lambda (options)
		     (sp.print_usage sys.stderr)
		     1)))

  (sp.set_defaults cli-func: cli-func)

  sp)


(def function main (argv: None)
  (doc "entry point for the sibapp CLI")

  ;; grab sys.argv if we aren't given something else
  (when (none? argv) (setq argv sys.argv))

  (var parser (create-option-parser argv))
  (var options (parser.parse_args
		(item-slice argv 1)))

  (try
   (options.cli-func options)

   ((KeyboardInterrupt as: ki)
    (print file: sys.stderr)
    130)

   (else: 0)))


(when (eq __name__ "__main__")
  (sys.exit (main)))


;; The end.
